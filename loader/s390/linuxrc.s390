#! /bin/sh
#
# Copyright (C) 2000,2001 by
#        Bernhard Rosenkraenzer <bero@redhat.com>
#        Oliver Paukstadt <opaukstadt@millenux.com>
#        Karsten Hopp <karsten@redhat.de>
#        Florian La Roche <laroche@redhat.com>
#        Nils Philippsen <nils@redhat.de>
#        Helge Deller <hdeller@redhat.de>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

debugshell()
{
	echo "You have defined DEBUG, so here is a shell. You can use 'exit'"
	echo "to go on with the normal installation process."
	/bin/sh
}

startinetd()
{
	echo
	echo "Starting telnetd and sshd to allow login over the network."
	/sbin/inetd
	/sbin/sshd
   while : ; do
		echo
		#echo "Please connect now to $IPADDR and start 'rhsetup' or start"
		#echo "'rhsetup nointeractive' from this shell."
		echo "Please connect now to $IPADDR and start 'loader' from this shell."
		/bin/sh -l
	done
	#	/sbin/mingetty console --noclear
}


echo "Starting the S390 initrd to configure networking. Version is 0.32."

PATH="/bin:/sbin:/usr/bin:/usr/sbin"
export PATH

#mount -n -o remount,rw /
mount -t proc none /proc
mount -t devpts /dev/pts /dev/pts 

ifconfig lo 127.0.0.1 netmask 255.0.0.0
route add -host 127.0.0.1 dev lo

[ -n "$DEBUG" ] && debugshell

LO=""

[ -L /sbin/insmod ] && LO=".o"

# Parse configuration
if [ -n "$HOST" ]; then
	set -- `echo $HOST |sed 's/:/ /g'`
	HNAME=$1
	DEVICE=$2
	NETTYPE=`echo $DEVICE |sed -e 's/[0-9].*//'`
	IPADDR=$3
	if [ ":$NETTYPE" = ":iucv" ]; then
		IUCV="iucv=$4"
		GATEWAY=$5
		MTU=$6
	elif [ ":$NETTYPE" = ":ctc" -o ":$NETTYPE" = ":escon" ]; then
		GATEWAY=$4
		MTU=$5
	else
		MTU=$4
	fi
fi
if [ -n "$MTU" ]; then
	MMTU="mtu $MTU"
fi
if [ -n "$NETWORK" ]; then
	set -- `echo $NETWORK | sed 's/:/ /g'`
	NETWORKIP=$1
	NETMASK=$2
	BROADCAST=$3
	if [ ":$NETTYPE" != ":ctc" -a ":$NETTYPE" != ":iucv" -a ":$NETTYPE" != ":escon" ]; then
		GATEWAY=$4
	fi
fi

# Check for missing parameters, prompt for them if necessary
while [ -z "$HNAME" ]; do
	echo "Please enter the FQDN of your new virtual machine (e.g. s390.redhat.com):"
	read HNAME
done
while [ -z "$DEVICE" ]; do
	echo "Please enter the network device you intend to use (e.g. ctc0, escon0, iucv0, eth0, tr0):"
	read DEVICE
	NETTYPE=`echo $DEVICE |sed -e 's/[0-9].*//'`
done
while [ -z "$IPADDR" ]; do
	echo "Please enter the IP address of your new virtual machine:"
	read IPADDR
done
if [ ":$NETTYPE" = ":eth" ] || [ ":$NETTYPE" = ":tr" ]; then
	while [ -z "$NETMASK" ]; do
		echo "Please enter your netmask (e.g. 255.255.255.0):"
		read NETMASK
	done
	while [ -z "$BROADCAST" ]; do
		echo "Please enter your broadcast address:"
		read BROADCAST
	done
	while [ -z "$NETWORKIP" ]; do
		echo "Please enter your network address:"
		read NETWORKIP
	done
	while [ -z "$GATEWAY" ]; do
		echo "Please enter your default gateway:"
		read GATEWAY
	done
	while [ -z "$LCS" ] && [ -z "$QETH" ]; do
		echo "(1) for OSA-2 with LCS or (2) for OSA-Express with QDIO/QETH"
		read INF
		while [ -z "$LCS" ] && [ ":$INF" = ":1" ]; do
			echo "OSA Device address (e.g. fc20,1 - or \"auto\" (may not work)):"
			read LCS
		done
		while [ -z "$QETH" ] && [ ":$INF" = ":2" ]; do
			echo "OSA-Express Device address (e.g. 0xf000,0xf001,0xf002 - or \"auto\" (may not work)):"
			read QETH
		done
	done
else
	while [ -z "$GATEWAY" ]; do
		echo "Enter the IP of your ctc/escon/iucv point-to-point partner:"
		read GATEWAY
	done
	if [ ":$NETTYPE" = ":iucv" ]; then
		while [ -z "$IUCV" ]; do
			echo "Enter iucv kernel module options (usually iucv=HOST):"
			read IUCV
		done
	fi
fi

# configure network-interface
if [ ":$NETTYPE" = ":ctc" -o ":$NETTYPE" = ":escon" ]; then
	insmod ctc$LO $CTC
	ifconfig $DEVICE $IPADDR $MMTU pointopoint $GATEWAY
	route add -host $IPADDR dev $DEVICE
elif [ ":$NETTYPE" = ":iucv" ]; then
	insmod netiucv$LO $IUCV
	ifconfig $DEVICE $IPADDR $MMTU pointopoint $GATEWAY
	route add -host $IPADDR dev $DEVICE
else
	if [ -z "$QETH" ]; then
		if [ ":$LCS" = ":auto" ]; then
			LCS=""
		else
			LCS=`echo $LCS | sed -e '/^0x\|^0X/ b; s/^/0x/'`
			LCS="noauto=1 devno_portno_pairs=$LCS"
		fi
		if [ -f /lib/lcs.o ]; then
			insmod -f /lib/lcs.o $LCS
		else
			echo "error: no lcs module found"
		fi
	else
		if [ ":$QETH" = ":auto" ]; then
			QETH="qeth_options="
		else
			QETH="qeth_options=noauto,$QETH"
		fi
		if [ -f /lib/qdio.o -a -f /lib/qeth.o ]; then
			insmod -f /lib/qdio.o
			insmod -f /lib/qeth.o $QETH
		else
			echo "error: The qdio and the qeth are needed for this"
			echo "They cannot be found in /lib, skipping..."
		fi
	fi
	ifconfig $DEVICE $IPADDR $MMTU netmask $NETMASK broadcast $BROADCAST
	route add -net $NETWORKIP netmask $NETMASK dev $DEVICE
fi
route add default gw $GATEWAY dev $DEVICE

[ -n "$HNAME" ] && hostname $HNAME

# show interfaces and routing table
ifconfig -a
route -n

[ -n "$DEBUG" ] && debugshell

echo "Starting portmap."
portmap

# convert to space-separated lists
DNS=`echo $DNS |sed -e 's/:/ /g'`
SEARCHDNS=`echo $SEARCHDNS |sed -e 's/:/ /g'`
for i in "$SEARCHDNS"; do echo "search $i"; done >> /etc/resolv.conf
for i in "$DNS"; do echo "nameserver $i"; done   >> /etc/resolv.conf
 
# transfer options into install environment
cat >> /etc/profile <<EOF
CHANDEV="$CHANDEV"
HOSTNAME="$HNAME"
DEVICE="$DEVICE"
NETTYPE="$NETTYPE"
IPADDR="$IPADDR"
GATEWAY="$GATEWAY"
MTU="$MTU"
NETWORKIP="$NETWORKIP"
NETMASK="$NETMASK"
BROADCAST="$BROADCAST"
INSTALL="$INSTALL"
INTERACTIVE="$INTERACTIVE"
DNS="$DNS"
SEARCHDNS="$SEARCHDNS"
RPMSERVER="$RPMSERVER"
MOUNTS="$MOUNTS"
FORCEDASDFORMAT="$FORCEDASDFORMAT"
SWAP="$SWAP"
DASD="$DASD"
LCS="$LCS"
QETH="$QETH"
IUCV="$IUCV"
CTC="$CTC"
DTZ="$DTZ"
ROOTPW="$ROOTPW"
CROOTPW="$CROOTPW"
export CHANDEV
export HNAME DEVICE NETTYPE IPADDR GATEWAY MTU INTERACTIVE
export NETWORKIP NETMASK BROADCAST INSTALL DNS SEARCHDNS FORCEDASDFORMAT
export RPMSERVER MOUNTS SWAP DASD LCS QETH IUCV DTZ ROOTPW CROOTPW
if [ -n "\$SSH_TTY" ]; then
	echo "Please start the program 'loader' to proceed with the installation"
	echo 
fi
EOF
# immediately read it in again to export these into the shell below
. /etc/profile

[ -n "$DEBUG" ] && debugshell

get_all_dasds()
{
	unset online_dasds
	TMP="`grep ':active' < /proc/dasd/devices | grep -v '\(^019\|none\)'`"
	for i in "$TMP"; do 
		online_dasds="`echo "$i" | 
			sed -e 's/.*   \(.*\):.*:.*/\/dev\/\1/'` $online_dasds"
	done
	if [ -z "$online_dasds" ]; then
		echo "No DASD devices found. Please check your setup."
		return 1
	else
		echo "DASD devices "
		echo "$online_dasds found."
		return 0
	fi
}

# Probe for DASD devices
if [ -z "$DASD" ]; then
	echo "If you know the address range of your DASDs, please enter it now."
	echo "If you just press return, autodetection will be attempted."
	echo "(200-20f is usually a good setting for vm, fd00-fd0f for LPARs)"
	echo "Danger: Autoprobing might give you wrong results!"
	read DASD
fi
if [ -z "$DASD" ]; then
	echo "Probing for DASD devices."
	insmod dasd_mod.o probeonly
	# ignore DASD devices at 019x (might be CMS)
	grep -v "\(^019\|none\)" /proc/dasd/devices > /tmp/dasd
	RANGE_START=""
	PREV=""
	for i in `sed -e 's/^\(....\).*/\1/' < /tmp/dasd`; do
		PREV=$ADDR
		ADDR=$i
		ADDR_DEC=`printf "%u" 0x$ADDR`
		if [ -z "$RANGE_START" ]; then
			RANGE_START=$ADDR
			RANGE_START_DEC=`printf "%u" 0x$RANGE_START`
		fi
		if [ "$ADDR_DEC" -lt "$RANGE_START_DEC" ]; then
			[ -n "$DASD" ] && DASD="$DASD,"
			DASD="$DASD$RANGE_START"
			LAST="$RANGE_START"
			if [ -n "$PREV" ] && [ "$PREV" != "$RANGE_START" ]; then
				DASD="${DASD}-$PREV"
				LAST="$PREV"
			fi
			PREV=""
			RANGE_START=$ADDR
		fi
	done
	if [ "$LAST" != "$ADDR" ]; then
		[ -n "$DASD" ] && DASD="$DASD,"
		DASD="$DASD$RANGE_START"
		[ "$ADDR" != "$RANGE_START" ] && DASD="${DASD}-$ADDR"
	fi
	echo "DASD ranges APPEAR to be $DASD."
	rmmod dasd_mod
fi

if [ -n "$DASD" ]; then
	 echo "Loading DASD kernel module. This can take a while."
	 insmod dasd_mod.o dasd=$DASD
	 insmod dasd_eckd_mod.o
fi

if [ ":$INTERACTIVE" = ":0" ]; then
	rhsetup nointeractive || startinetd
else
	startinetd
fi

umount -a
umount /proc
#umount /

exit 0
# vim:ts=3:sw=3
# ;;; Local Variables: ***
# ;;; mode: sh ***
# ;;; tab-width:3 ***
# ;;; end: ***
