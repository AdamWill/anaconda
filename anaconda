#!/usr/bin/python2.2
#
# anaconda: The Red Hat Linux Installation program
#
# (in alphabetical order...)
#
# Brent Fox <bfox@redhat.com>
# Mike Fulbright <msf@redhat.com>
# Jakub Jelinek <jakub@redhat.com>
# Jeremy Katz <katzj@redhat.com>
# Erik Troan <ewt@redhat.com>
# Matt Wilson <msw@redhat.com>
#
# ... And many others
#
# Copyright 1999-2002 Red Hat, Inc.
#
# This software may be freely redistributed under the terms of the GNU
# library public license.
#
# You should have received a copy of the GNU Library Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

# This toplevel file is a little messy at the moment...

import sys, os

# keep up with process ID of miniwm if we start it

miniwm_pid = None
# helper function to duplicate diagnostic output
def dup_log(format, *args):
    if args:
	sys.stdout.write ("%s\n" % (format % args))
    else:
	sys.stdout.write ("%s\n" % format)
    apply(log, (format,) +  args)

# start miniWM
def startMiniWM(root='/'):
    childpid = os.fork()
    if not childpid:
	args = [root + '/usr/bin/mini-wm', '--display', ':1']
	os.execv(args[0], args)
	sys.exit (1)

    return childpid
	
# function to handle X startup special issues for anaconda
def doStartupX11Actions():
    global miniwm_pid

    # now start up mini-wm
    try:
	miniwm_pid = startMiniWM()
	log("Started mini-wm")
    except:
	miniwm_pid = None
	log("Unable to start mini-wm")

    # test to setup dpi
    # cant do this if miniwm didnt run because otherwise when
    # we open and close an X connection in the xutils calls
    # the X server will exit since this is the first X
    # connection (if miniwm isnt running)
    if miniwm_pid is not None:
	import xutils

	try:
	    if xutils.screenWidth() > 640:
		dpi = "96"
	    else:
		dpi = "75"

	    xutils.setRootResource('Xft.antialias', '1')
	    xutils.setRootResource('Xft.dpi', dpi)
	    xutils.setRootResource('Xft.hinting', '1')
	    xutils.setRootResource('Xft.hintstyle', 'hintslight')
	    xutils.setRootResource('Xft.rgba', 'none')
	except:
	    sys.stderr.write("X SERVER STARTED, THEN FAILED");
	    raise RuntimeError, "X server failed to start"
    
def doShutdownX11Actions():
    global miniwm_pid
    
    if miniwm_pid is not None:
	try:
	    os.kill(miniwm_pid, 15)
	    os.waitpid(miniwm_pid, 0)
	except:
	    pass


    
# For anaconda in test mode
if (os.path.exists('isys')):
    sys.path.append('libfdisk')
    sys.path.append('balkan')
    sys.path.append('gnome-map')
    sys.path.append('isys')
    sys.path.append('textw')
    sys.path.append('iw')
    sys.path.append('installclasses')
    sys.path.append('iconvmodule')
else:
    sys.path.append('/usr/lib/anaconda')
    sys.path.append('/usr/lib/anaconda/textw')
    sys.path.append('/usr/lib/anaconda/iw')
    sys.path.append('/usr/lib/anaconda/installclasses')

if (os.path.exists('booty')):
    sys.path.append('booty')
    sys.path.append('booty/edd')
else:
    sys.path.append('/usr/lib/booty')

sys.path.append('/usr/share/redhat-config-keyboard')

try:
    import updates_disk_hook
except ImportError:
    pass

# do this early to keep our import footprint as small as possible
# Python passed my path as argv[0]!
# if sys.argv[0][-7:] == "syslogd":
if len(sys.argv) > 1:
    if sys.argv[1] == "--syslogd":
        from syslogd import Syslogd
        root = sys.argv[2]
        output = sys.argv[3]
        syslog = Syslogd (root, open (output, "a"))
	# this never returns

import signal, traceback, string, isys, iutil, time

from exception import handleException
import dispatch
from flags import flags
from anaconda_log import anaconda_log

from rhpl.log import log
from rhpl.translate import _, textdomain

textdomain("anaconda")

# reset python's default SIGINT handler
signal.signal(signal.SIGINT, signal.SIG_DFL)

# Silly GNOME stuff
if os.environ.has_key('HOME'):
    os.environ['XAUTHORITY'] = os.environ['HOME'] + '/.Xauthority'
os.environ['HOME'] = '/tmp'
os.environ['LC_NUMERIC'] = 'C'

if os.environ.has_key ("ANACONDAARGS"):
    theargs = string.split (os.environ["ANACONDAARGS"])
else:
    theargs = sys.argv[1:]

# we can't let the LD_PRELOAD hang around because it will leak into
# rpm %post and the like.  ick :/
if os.environ.has_key("LD_PRELOAD"):
    del os.environ["LD_PRELOAD"]

try:
    (args, extra) = isys.getopt(theargs, 'GTRxtdr:fm:', 
          [ 'text', 'xmode', 'test', 'debug', 'nofallback',
            'method=', 'rootpath=', 'pcic=', "overhead=",
	    'testpath=', 'mountfs', 'traceonly', 'kickstart=',
            'lang=', 'keymap=', 'kbdtype=', 'module=', 'class=',
	    'expert', 'serial', 'lowres', 'nofb', 'rescue', 'nomount',
            'autostep', 'resolution=', 'skipddc'])
except TypeError, msg:
    sys.stderr.write("Error %s\n:" % msg)
    sys.exit(-1)

if extra:
    sys.stderr.write("Unexpected arguments: %s\n" % extra)
    sys.exit(-1)

# Save the arguments in case we need to reexec anaconda for kon
os.environ["ANACONDAARGS"] = string.join(sys.argv[1:])

# remove the arguments - gnome_init doesn't understand them
savedargs = sys.argv[1:]
sys.argv = sys.argv[:1]
sys.argc = 1

# Parameters for the main anaconda routine
#
rootPath = '/mnt/sysimage'	# where to instal packages
extraModules = []		# kernel modules to use
display_mode = 'g'		# try GUI by default
xmode = 0			# bring up text mode in a remote xterm?
debug = 0			# start up pdb immediately
traceOnly = 0			# don't run, just list modules we use
nofallback = 0			# if GUI mode fails, exit
rescue = 0			# run in rescue mode
rescue_nomount = 0		# don't automatically mount device in rescue
runres = '800x600'		# resolution to run the GUI install in
skipddc = 0			# if true skip ddcprobe (locks some machines)
instClass = None		# the install class to use
progmode = 'install' 		# 'rescue', or 'install'
method = None			# URL representation of install method
logFile = None			# may be a file object or a file name

#
# xcfg       - xserver info (?)
# mousehw    - mouseinfo info
# videohw    - videocard info
# monitorhw  - monitor info
# lang       - language to use for install/machine default
# keymap     - kbd map
#
xcfg = None
monitorhw = None
videohw = None
mousehw = None
lang = None
method = None
keymap = None
kbdtype = None
progmode = None
customClass = None
kbd = None

#
# parse off command line arguments
#
for n in args:
    (str, arg) = n

    if (str == '--class'):
        customClass = arg
    elif (str == '-d' or str == '--debug'):
	debug = 1
    elif (str == '--expert'):
	flags.expert = 1 
    elif (str == '--keymap'):
        keymap = arg
    elif (str == '--kickstart'):
	from kickstart import Kickstart
        instClass = Kickstart(arg, flags.serial)
    elif (str == '--lang'):
        lang = arg
    elif (str == '--lowres'):
        runres = '640x480'
    elif (str == '-m' or str == '--method'):
	method = arg
	if method[0] == '@':
	    # ftp installs pass the password via a file in /tmp so
	    # ps doesn't show it
	    filename = method[1:]
	    method = open(filename, "r").readline()
	    method = method[:len(method) - 1]
	    os.unlink(filename)
    elif (str == '--module'):
	(path, subdir, name) = string.split(arg, ":")
	extraModules.append((path, subdir, name))
    elif (str == '--nofallback'):
	nofallback = 1
    elif (str == "--nomount"):
        rescue_nomount = 1
    elif (str == '--rescue'):
        progmode = 'rescue'
    elif (str == '--resolution'):
        # run native X server at specified resolution, ignore fb
        runres = arg
    elif (str == "--skipddc"):	
	skipddc = 1
    elif (str == "--autostep"):
	flags.autostep = 1
    elif (str == '-r' or str == '--rootpath'):
	rootPath = arg
	flags.setupFilesystems = 0
	logFile = sys.stderr
    elif (str == '--traceonly'):
	traceOnly = 1
    elif (str == '--serial'):
	logFile = "/tmp/install.log"
	flags.serial = 1
    elif (str == '-t' or str == '--test'):
	flags.test = 1
	flags.setupFilesystems = 0
	logFile = "/tmp/anaconda-debug.log"
    elif (str == '-T' or str == '--text'):
	display_mode = 't'
    elif (str == '-x' or str == '--xmode'):
	xmode = 1
    elif (str == '--kbdtype'):
        kbdtype = arg

# s390s don't have ttys
if iutil.getArch() == "s390":
    logFile = "/tmp/anaconda-s390.log"
    #display_mode = 't'

#
# must specify install, rescue mode
#

if (progmode == 'rescue'):
    if (not method):
	sys.stderr.write('--method required for rescue mode\n')
	sys.exit(1)

    import rescue, instdata, configFileData
    
    anaconda_log.open (logFile)
    log.handler=anaconda_log
    
    configFile = configFileData.configFileData()
    configFileData = configFile.getConfigData()
    
    id = instdata.InstallData([], "fd0", configFileData, method)
    rescue.runRescue(rootPath, not rescue_nomount, id)

    # shouldn't get back here
    sys.exit(1)
else:
    if (not method):
	sys.stderr.write('no install method specified\n')
	sys.exit(1)

anaconda_log.open (logFile)
log.handler = anaconda_log

if (debug):
    import pdb
    pdb.set_trace()

# let people be stupid
## # don't let folks do anything stupid on !s390
## if (not flags.test and os.getpid() > 90 and flags.setupFilesystems and
##     not iutil.getArch() == "s390"):
##     sys.stderr.write(
##         "You're running me on a live system! that's incredibly stupid.\n")
##     sys.exit(1)

import isys
import instdata
import floppy
import xsetup

import rhpl.xhwstate as xhwstate
import rhpl.keyboard as keyboard

# handle traceonly and exit
if traceOnly:

    if display_mode == 'g':
        sys.stderr.write("traceonly is only supported for text mode\n")
        sys.exit(0)
    
    # prints a list of all the modules imported
    from text import InstallInterface
    from text import stepToClasses
    import pdb
    import image
    import harddrive
    import urlinstall
    import mimetools
    import mimetypes
    import syslogd
    import installclass
    import re
    import rescue
    import configFileData
    import kickstart
    import whiteout
    import findpackageset
    import libxml2

    installclass.availableClasses()

    if display_mode == 't':
        for step in stepToClasses.keys():
            if stepToClasses[step]:
                (mod, klass) = stepToClasses[step]
                exec "import %s" % mod
        
    for module in sys.__dict__['modules'].keys ():
        if module not in [ "__builtin__", "__main__" ]:
            foo = repr (sys.__dict__['modules'][module])
            bar = string.split (foo, "'")
            if len (bar) > 3:
                print bar[3]
        
    sys.exit(0)

#
# override display mode if machine cannot nicely run X
#
if (not flags.test):
    if (iutil.memInstalled() < isys.MIN_GUI_RAM):
	dup_log(_("You do not have enough RAM to use the graphical "
		  "installer.  Starting text mode."))
	display_mode = 't'
        time.sleep(2)


if iutil.memInstalled() < isys.MIN_RAM:
    from snack import *

    screen = SnackScreen()
    ButtonChoiceWindow(screen, _('Fatal Error'),
			_('You do not have enough RAM to install Red Hat '
			  'Linux on this machine.\n'
			  '\n'
			  'Press <return> to reboot your system.\n'), 
			  buttons = (_("OK"),))
    screen.finish()
    sys.exit(0)

#
# handle class passed from loader
#
if customClass:
    import installclass

    classes = installclass.availableClasses(showHidden=1)
    for (className, objectClass, logo) in classes:
	if className == customClass:
		instClass = objectClass(flags.expert)

    if not instClass:
	sys.stderr.write("installation class %s not available\n" % customClass)
	sys.stderr.write("\navailable classes:\n")
	for (className, objectClass, logo) in classes:
	    sys.stderr.write("\t%s\n" % className)
	sys.exit(1)

#
# if no instClass declared by user figure it out based on other cmdline args
#
if not instClass:
    from installclass import DefaultInstall
    instClass = DefaultInstall(flags.expert)

# this lets install classes force text mode instlls
if instClass.forceTextMode:
    display_mode = 't'

#
# find out what video hardware is available to run installer 
#

# XXX kind of hacky - need to remember if we're running on an existing
#                     X display later to avoid some initilization steps
if os.environ.has_key('DISPLAY') and display_mode == 'g':
    x_already_set = 1
else:
    x_already_set = 0

#
# Probe what is available for X and setup a hardware state
#
# try to probe interesting hw
import rhpl.xserver as xserver
skipddcprobe = (skipddc or (x_already_set and flags.test))
skipmouseprobe = not (not os.environ.has_key('DISPLAY') or flags.setupFilesystems)

(videohw, monitorhw, mousehw) = xserver.probeHW(skipDDCProbe=skipddcprobe,
						skipMouseProbe = skipmouseprobe)

# keyboard
kbd = keyboard.Keyboard()
if keymap:
    kbd.set(keymap)

# setup a X hw state for use later with configuration
xcfg = xhwstate.XF86HardwareState(defcard=videohw, defmon=monitorhw)
try:
    xcfg = xhwstate.XF86HardwareState(defcard=videohw, defmon=monitorhw)
except:
    print _("Unable to instantiate a X hardware state object.")
    xcfg = None

#
# delay to let use see status of attempt to probe hw 
#
time.sleep(3)


#
# now determine if we're going to run in GUI or TUI mode
#
if (display_mode != 't' and method and
    method.startswith('ftp://') or
    method.startswith('http://') or
    method.startswith('hd://') or
    method.startswith('oldhd://')):
    dup_log(_("Graphical installation not available for %s installs.  "
             "Starting text mode.") % (string.split(method, ':')[0],))
    display_mode = 't'
    time.sleep(2)

# XXX should be fixed to be more generic instead of just ifarching
if iutil.getArch() != "s390":
    # if no mouse we force text mode
    mousedev = mousehw.get()
    if display_mode != 't' and mousedev[0] == "No - mouse":
        # ask for the mouse type
	import rhpl.mouse as mouse

        if mouse.mouseWindow(mousehw) == 0:
	    dup_log(_("No mouse was detected.  A mouse is required for "
		      "graphical installation.  Starting text mode."))
            display_mode = 't'
            time.sleep(2)
        else:
	    dup_log(_("Using mouse type: %s"), mousehw.shortDescription())
else: # s390 checks
    if display_mode == 'g' and not os.environ.has_key('DISPLAY'):
	dup_log("DISPLAY variable not set. Starting text mode!")
        display_mode = 't'
        time.sleep(2)

if display_mode == 'g' and not os.environ.has_key('DISPLAY'):
    import rhpl.monitor as monitor
    
    # if no monitor probed lets guess based on runres
    hsync = monitorhw.getMonitorHorizSync()
    vsync = monitorhw.getMonitorVertSync()
    res_supported = monitor.monitor_supports_mode(hsync, vsync,  runres)
    
    if not res_supported:
	if runres == "800x600":
	    monitorhw.setSpecs("31.5-48.5", "50-70")
	elif runres == "1024x768":
	    monitorhw.setSpecs("31.5-48.5", "40-70")
	elif runres == "1280x1024":
	    monitorhw.setSpecs("31.5-67", "50-75")
	elif runres == "1400x1050":
	    monitorhw.setSpecs("31.5-90", "59-75")
	elif runres == "1600x1200":
	    monitorhw.setSpecs("31.5-90", "60")
	else:
	    # just pick something reasonable for most modes
	    monitorhw.setSpecs("31.5-65.0", "50-90")

	# XXX - need to fix
	#
	# messy hack for how rhpl.xhwstate works
	# current it wants to use probed values which we dont have so we'll
	# fake them
	hsync = monitorhw.getMonitorHorizSync()
	vsync = monitorhw.getMonitorVertSync()
	monitorhw.orig_monHoriz = hsync
	monitorhw.orig_monVert  = vsync

    xsetup_failed = xserver.startXServer(videohw, monitorhw, mousehw, kbd,
					 runres,
					 xStartedCB=doStartupX11Actions,
					 xQuitCB=doShutdownX11Actions)

    if xsetup_failed:
	dup_log(" X startup failed, falling back to text mode")
	display_mode = 't'
	time.sleep(2)

#
# read in anaconda configuration file
#
import configFileData
configFile = configFileData.configFileData()
configFileData = configFile.getConfigData()

# setup links required for all install types
for i in ( "services", "protocol", "nsswitch.conf"):
    try:
        os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
    except:
        pass

#
# setup links required by graphical mode if installing and verify display mode
#
if (display_mode == 'g'):
    if not flags.test and flags.setupFilesystems:
        for i in ( "imrc", "im_palette.pal", "gtk-2.0", "pango", "fonts"):
            try:
                os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
            except:
                pass

    # display splash screen

    if nofallback:
	from splashscreen import splashScreenShow
	splashScreenShow(configFileData)
	
        from gui import InstallInterface
    else:
        try:
	    from splashscreen import splashScreenShow
	    splashScreenShow(configFileData)
	    
            from gui import InstallInterface
        except:
            # if we're not going to really go into GUI mode, we need to get
            # back to vc1 where the text install is going to pop up.
	    if not x_already_set:
                isys.vtActivate (1)
            dup_log("GUI installer startup failed, falling back to text mode.")
            display_mode = 't'
	    if 'DISPLAY' in os.environ.keys():
		del os.environ['DISPLAY']
            time.sleep(2)            
            from text import InstallInterface

if (display_mode == 't'):
    from text import InstallInterface
    from text import stepToClasses


# we like to have a way to shoot text mode back at a display
if xmode:
    os.environ["TERM"] = "xterm"
    import gtk
    import vte

    def child_died (widget, *args):
        gtk.mainquit()

    win = gtk.Window ()
    term = vte.Terminal ()
    term.set_encoding("UTF-8")
    term.set_font_from_string("monospace 10")
    term.set_color_background(gtk.gdk.color_parse('white'))
    term.set_color_foreground(gtk.gdk.color_parse('black'))
    term.connect ("child_exited", child_died)
    term.reset(gtk.TRUE, gtk.TRUE)
    win.add (term)
    win.show_all ()
    child = term.forkpty()
    if child != 0:
        gtk.mainloop()
        try:
            pid, status = os.waitpid(child, 0)
        except OSError:
            pass
        sys.exit (0)

if display_mode == "t":
    intf = InstallInterface ()
else:
    # determine the mode we actually ended up in
    intf = InstallInterface ()

# imports after setting up the path
if method:
    if method.startswith('cdrom://'):
        from image import CdromInstallMethod
        methodobj = CdromInstallMethod(method[8:], intf.messageWindow,
				    intf.progressWindow, rootPath)
    elif method.startswith('nfs:/'):
        from image import NfsInstallMethod
        methodobj = NfsInstallMethod(method[5:], rootPath)
    elif method.startswith('nfsiso:/'):
        from image import NfsIsoInstallMethod
        methodobj = NfsIsoInstallMethod(method[8:], intf.messageWindow, rootPath)
    elif method.startswith('ftp://') or method.startswith('http://'):
        from urlinstall import UrlInstallMethod
        methodobj = UrlInstallMethod(method, rootPath)
    elif method.startswith('hd://'):
        tmpmethod = method[5:]

        i = string.index(tmpmethod, ":")
        drive = tmpmethod[0:i]
        tmpmethod = tmpmethod[i+1:]
        
        i = string.index(tmpmethod, "/")
        type = tmpmethod[0:i]
        dir = tmpmethod[i+1:]

        from harddrive import HardDriveInstallMethod
        methodobj = HardDriveInstallMethod(drive, type, dir, intf.messageWindow,
                                        rootPath)
    elif method.startswith('oldhd://'):
        tmpmethod = method[8:]

        i = string.index(tmpmethod, ":")
        drive = tmpmethod[0:i]
        tmpmethod = tmpmethod[i+1:]
        
        i = string.index(tmpmethod, "/")
        type = tmpmethod[0:i]
        dir = tmpmethod[i+1:]
        
        from harddrive import OldHardDriveInstallMethod
        methodobj = OldHardDriveInstallMethod(drive, type, dir, rootPath)
    else:
        print "unknown install method:", method
        sys.exit(1)

floppyDevice = floppy.probeFloppyDevice()

# create device nodes for detected devices if we're not running in test mode
if not flags.test and flags.setupFilesystems:
    iutil.makeDriveDeviceNodes()

id = instClass.installDataClass(extraModules, floppyDevice, configFileData, method)

id.x_already_set = x_already_set

if mousehw:
    id.setMouse(mousehw)

if videohw:
    id.setVideoCard(videohw)

if monitorhw:
    id.setMonitor(monitorhw)

#
# not sure what to do here - somehow we didnt detect anything
#
if xcfg is None:
    try:
	xcfg = xhwstate.XF86HardwareState()
    except:
	print _("Unable to instantiate a X hardware state object.")
	xcfg = None

if xcfg is not None:
    xsetup = xsetup.XSetup(xcfg)
    id.setXSetup(xsetup)

if kbd:
    id.setKeyboard(kbd)
    
instClass.setInstallData(id)

dispatch = dispatch.Dispatcher(intf, id, methodobj, rootPath)

if lang:
    dispatch.skipStep("language", permanent = 1)
    instClass.setLanguage(id, lang)
            
if keymap:
    dispatch.skipStep("keyboard", permanent = 1)
    instClass.setKeyboard(id, keymap)

instClass.setSteps(dispatch)

# We shouldn't need this again
# XXX
#del id

#
# XXX This is surely broken
#
#if iutil.getArch() == "sparc":
#    import kudzu
#    mice = kudzu.probe (kudzu.CLASS_MOUSE, kudzu.BUS_UNSPEC, kudzu.PROBE_ONE);
#    if mice:
#	(mouseDev, driver, descr) = mice[0]
#	if mouseDev == 'sunmouse':
#	    instClass.addToSkipList("mouse")
#	    instClass.setMouseType("Sun - Mouse", "sunmouse")

# comment out the next line to make exceptions non-fatal
sys.excepthook = lambda type, value, tb, dispatch=dispatch, intf=intf: handleException(dispatch, intf, (type, value, tb))

try:
    intf.run(id, dispatch, configFileData)
except SystemExit, code:
    intf.shutdown()
except:
    handleException(dispatch, intf, sys.exc_info())

del intf
