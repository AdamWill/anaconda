#!/usr/bin/python2.2
#
# anaconda: The Red Hat Linux Installation program
#
# (in alphabetical order...)
#
# Brent Fox <bfox@redhat.com>
# Mike Fulbright <msf@redhat.com>
# Jakub Jelinek <jakub@redhat.com>
# Jeremy Katz <katzj@redhat.com>
# Erik Troan <ewt@redhat.com>
# Matt Wilson <msw@redhat.com>
#
# ... And many others
#
# Copyright 1999-2002 Red Hat, Inc.
#
# This software may be freely redistributed under the terms of the GNU
# library public license.
#
# You should have received a copy of the GNU Library Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

# This toplevel file is a little messy at the moment...

import sys, os

# For anaconda in test mode
if (os.path.exists('isys')):
    sys.path.append('libfdisk')
    sys.path.append('balkan')
    sys.path.append('gnome-map')
    sys.path.append('isys')
    sys.path.append('textw')
    sys.path.append('iw')
    sys.path.append('installclasses')
    sys.path.append('iconvmodule')
else:
    sys.path.append('/usr/lib/anaconda')
    sys.path.append('/usr/lib/anaconda/textw')
    sys.path.append('/usr/lib/anaconda/iw')
    sys.path.append('/usr/lib/anaconda/installclasses')

if (os.path.exists('booty')):
    sys.path.append('booty')
    sys.path.append('booty/edd')
else:
    sys.path.append('/usr/lib/booty')

sys.path.append('/usr/share/redhat-config-keyboard')

try:
    import updates_disk_hook
except ImportError:
    pass

# do this early to keep our import footprint as small as possible
# Python passed my path as argv[0]!
# if sys.argv[0][-7:] == "syslogd":
if len(sys.argv) > 1:
    if sys.argv[1] == "--syslogd":
        from syslogd import Syslogd
        root = sys.argv[2]
        output = sys.argv[3]
        syslog = Syslogd (root, open (output, "a"))
	# this never returns

import signal, traceback, string, isys, iutil, time

from exception import handleException
import dispatch
from flags import flags
from anaconda_log import anaconda_log

from rhpl.log import log
from rhpl.translate import _, textdomain

textdomain("anaconda")

# reset python's default SIGINT handler
signal.signal(signal.SIGINT, signal.SIG_DFL)

# Silly GNOME stuff
if os.environ.has_key('HOME'):
    os.environ['XAUTHORITY'] = os.environ['HOME'] + '/.Xauthority'
os.environ['HOME'] = '/tmp'
os.environ['LC_NUMERIC'] = 'C'

if os.environ.has_key ("ANACONDAARGS"):
    theargs = string.split (os.environ["ANACONDAARGS"])
else:
    theargs = sys.argv[1:]

try:
    (args, extra) = isys.getopt(theargs, 'GTRxtdr:fm:', 
          [ 'text', 'xmode', 'test', 'debug', 'nofallback',
            'method=', 'rootpath=', 'pcic=', "overhead=",
	    'testpath=', 'mountfs', 'traceonly', 'kickstart=',
            'lang=', 'keymap=', 'module=', 'class=',
	    'expert', 'serial', 'lowres', 'nofb', 'rescue', 'nomount',
            'autostep', 'resolution=', 'skipddc'])
except TypeError, msg:
    sys.stderr.write("Error %s\n:" % msg)
    sys.exit(-1)

if extra:
    sys.stderr.write("Unexpected arguments: %s\n" % extra)
    sys.exit(-1)

# Save the arguments in case we need to reexec anaconda for kon
os.environ["ANACONDAARGS"] = string.join(sys.argv[1:])

# remove the arguments - gnome_init doesn't understand them
savedargs = sys.argv[1:]
sys.argv = sys.argv[:1]
sys.argc = 1

# Parameters for the main anaconda routine
#
rootPath = '/mnt/sysimage'	# where to instal packages
extraModules = []		# kernel modules to use
display_mode = 'g'		# try GUI by default
xmode = 0			# bring up text mode in a remote xterm?
debug = 0			# start up pdb immediately
traceOnly = 0			# don't run, just list modules we use
nofallback = 0			# if GUI mode fails, exit
rescue = 0			# run in rescue mode
rescue_nomount = 0		# don't automatically mount device in rescue
overhead = 0			# kilobytes of memory used already
runres = '800x600'		# resolution to run the GUI install in
nofbmode = 1			# don't use framebuffer X, no matter what
skipddc = 0			# if true skip ddcprobe (locks some machines)
instClass = None		# the install class to use
progmode = 'install' 		# 'rescue', or 'install'
method = None			# URL representation of install method
logFile = None			# may be a file object or a file name

#
# xcfg       - xserver info (?)
# mousehw    - mouseinfo info
# videohw    - videocard info
# monitorhw  - monitor info
# lang       - language to use for install/machine default
# keymap     - kbd map
#
xcfg = None
monitorhw = None
videohw = None
mousehw = None
lang = None
method = None
keymap = None
kbdtpye = None
progmode = None
customClass = None
kbd = None

#
# parse off command line arguments
#
for n in args:
    (str, arg) = n

    if (str == '--class'):
        customClass = arg
    elif (str == '-d' or str == '--debug'):
	debug = 1
    elif (str == '--expert'):
	flags.expert = 1 
    elif (str == '--keymap'):
        keymap = arg
    elif (str == '--kickstart'):
	from kickstart import Kickstart
        instClass = Kickstart(arg, flags.serial)
    elif (str == '--lang'):
        lang = arg
    elif (str == '--lowres'):
        runres = '640x480'
    elif (str == '-m' or str == '--method'):
	method = arg
	if method[0] == '@':
	    # ftp installs pass the password via a file in /tmp so
	    # ps doesn't show it
	    filename = method[1:]
	    method = open(filename, "r").readline()
	    method = method[:len(method) - 1]
	    os.unlink(filename)
    elif (str == '--module'):
	(path, subdir, name) = string.split(arg, ":")
	extraModules.append((path, subdir, name))
    elif (str == '--nofallback'):
	nofallback = 1
#
# we're removing fb support
#
#    elif (str == '--nofb'):
#        nofbmode = 1
    elif (str == "--nomount"):
        rescue_nomount = 1
    elif (str == '--overhead'):
	overhead = int(arg)
    elif (str == '--rescue'):
        progmode = 'rescue'
    elif (str == '--resolution'):
        # run native X server at specified resolution, ignore fb
        runres = arg
#
# we're removing fb support
#
#        nofbmode = 1
    elif (str == "--skipddc"):	
	skipddc = 1
    elif (str == "--autostep"):
	flags.autostep = 1
    elif (str == '-r' or str == '--rootpath'):
	rootPath = arg
	flags.setupFilesystems = 0
	logFile = sys.stderr
    elif (str == '--traceonly'):
	traceOnly = 1
    elif (str == '--serial'):
	logFile = "/tmp/install.log"
	flags.serial = 1
    elif (str == '-t' or str == '--test'):
	flags.test = 1
	flags.setupFilesystems = 0
	logFile = "/tmp/anaconda-debug.log"
    elif (str == '-T' or str == '--text'):
	display_mode = 't'
    elif (str == '-x' or str == '--xmode'):
	xmode = 1

#  Force text mode on IBM s390/s390x.
#  s390s don't have ttys
if iutil.getArch() == "s390" or iutil.getArch() == "s390x":
    logFile = "/tmp/anaconda-s390.log"
    display_mode = 't'


#
# must specify install, rescue mode
#

if (progmode == 'rescue'):
    if (not method):
	sys.stderr.write('--method required for rescue mode\n')
	sys.exit(1)

    import rescue, instdata, configFileData
    
    anaconda_log.open (logFile)
    log.handler=anaconda_log
    
    configFile = configFileData.configFileData()
    configFileData = configFile.getConfigData()
    
    id = instdata.InstallData([], "fd0", configFileData)
    rescue.runRescue(rootPath, not rescue_nomount, id)

    # shouldn't get back here
    sys.exit(1)
else:
    if (not method):
	sys.stderr.write('no install method specified\n')
	sys.exit(1)

anaconda_log.open (logFile)
log.handler = anaconda_log

if (debug):
    import pdb
    pdb.set_trace()

# let people be stupid
## # don't let folks do anything stupid on !s390
## if (not flags.test and os.getpid() > 90 and flags.setupFilesystems and
##     not iutil.getArch() == "s390"):
##     sys.stderr.write(
##         "You're running me on a live system! that's incredibly stupid.\n")
##     sys.exit(1)

import isys
import instdata
import floppy

import rhpl.videocard as videocard
import rhpl.monitor as monitor
import rhpl.mouse as mouse
import rhpl.keyboard as keyboard

# handle traceonly and exit
if traceOnly:

    if display_mode == 'g':
        sys.stderr.write("traceonly is only supported for text mode\n")
        sys.exit(0)
    
    # prints a list of all the modules imported
    from text import InstallInterface
    from text import stepToClasses
    import pdb
    import image
    import harddrive
    import urlinstall
    import mimetools
    import mimetypes
    import syslogd
    import installclass
    import re
    import rescue
    import xserver
    import configFileData
    import kickstart
    import whiteout

    installclass.availableClasses()

    if display_mode == 't':
        for step in stepToClasses.keys():
            if stepToClasses[step]:
                (mod, klass) = stepToClasses[step]
                exec "import %s" % mod
        
    for module in sys.__dict__['modules'].keys ():
        if module not in [ "__builtin__", "__main__" ]:
            foo = repr (sys.__dict__['modules'][module])
            bar = string.split (foo, "'")
            if len (bar) > 3:
                print bar[3]
        
    sys.exit(0)

iutil.setMemoryOverhead(overhead)

#
# override display mode if machine cannot nicely run X
#
if (not flags.test):
    if (iutil.memInstalled() < isys.MIN_GUI_RAM):
        print _("You do not have enough RAM to use the graphical installer.  "
                "Starting text mode.")
	display_mode = 't'
        time.sleep(2)


if iutil.memInstalled() < isys.MIN_RAM:
    from snack import *

    screen = SnackScreen()
    ButtonChoiceWindow(screen, _('Fatal Error'),
			_('You do not have enough RAM to install Red Hat '
			  'Linux on this machine.\n'
			  '\n'
			  'Press <return> to reboot your system.\n'), 
			  buttons = (_("OK"),))
    screen.finish()
    sys.exit(0)

#
# handle class passed from loader
#
if customClass:
    import installclass

    classes = installclass.availableClasses(showHidden=1)
    for (className, objectClass, logo) in classes:
	if className == customClass:
		instClass = objectClass(flags.expert)

    if not instClass:
	sys.stderr.write("installation class %s not available\n" % customClass)
	sys.stderr.write("\navailable classes:\n")
	for (className, objectClass, logo) in classes:
	    sys.stderr.write("\t%s\n" % className)
	sys.exit(1)

#
# if no instClass declared by user figure it out based on other cmdline args
#
if not instClass:
    from installclass import DefaultInstall
    instClass = DefaultInstall(flags.expert)

# this lets install classes force text mode instlls
if instClass.forceTextMode:
    display_mode = 't'

#
# find out what video hardware is available to run installer 
#

# XXX kind of hacky
if os.environ.has_key('DISPLAY') and display_mode == 'g':
    x_already_set = 1
else:
    x_already_set = 0

mousehw    = mouse.Mouse(skipProbe = 1)

sys.stdout.write(    _("Probing for video card:   "))
fbdev = None
videohw    = videocard.VideoCardInfo(skipDDCProbe = (skipddc or flags.test))

if videohw and videohw.primaryCard():
    sys.stdout.write(videohw.primaryCard().shortDescription()+'\n')
#    fbdev = videohw.primaryCard().getDevice()
else:
    sys.stdout.write(_("Unable to probe\n"))

sys.stdout.write(    _("Probing for monitor type: "))
monitorhw  = monitor.MonitorInfo(fbDevice=fbdev, skipDDCProbe = (skipddc or flags.test))
sys.stdout.write(monitorhw.shortDescription()+'\n')

kbd = keyboard.Keyboard()
if keymap:
    kbd.set(keymap)

# only probe if we're installing a real box or
# we're running in a virtual console and need to startup X server
if not os.environ.has_key('DISPLAY') or flags.setupFilesystems:
    sys.stdout.write(_("Probing for mouse type:   "))
    mousehw.probe (frob = 1)
    sys.stdout.write(mousehw.shortDescription()+'\n')
else:
    sys.stdout.write(_("Skipping mouse probe.\n"))

if (display_mode != 't' and method and
    method.startswith('ftp://') or
    method.startswith('http://') or
    method.startswith('hd://') or
    method.startswith('oldhd://')):
    print _("Graphical installation not available for %s installs.  "
            "Starting text mode.") % (string.split(method, ':')[0],)
    display_mode = 't'
    time.sleep(2)

# XXX should be fixed to be more generic instead of just ifarching
if iutil.getArch() != "s390" and iutil.getArch() != "s390x":
    # if no mouse we force text mode
    mousedev = mousehw.get()
    if display_mode != 't' and mousedev[0] == "None - None":
        # ask for the mouse type
        if mouse.mouseWindow(mousehw) == 0:
            print _("No mouse was detected.  A mouse is required for graphical "
                "installation.  Starting text mode.")
            display_mode = 't'
            time.sleep(2)
        else:
            sys.stdout.write(_("Using mouse type: "))
            sys.stdout.write(mousehw.shortDescription()+'\n')
else: # s390 checks
    if display_mode == 'g' and not os.environ.has_key('DISPLAY'):
        print _("DISPLAY variable not set. Starting text mode!")
        display_mode = 't'
        time.sleep(2)


#
# startup X server is we're not already running under an X session
#
startXServer = 0

if display_mode == 'g':
    import xf86config

    if not os.environ.has_key('DISPLAY'):
        startXServer = 1
        import xserver
        try:
            if os.access("/etc/X11/XF86Config", os.R_OK) or os.access("/etc/X11/XF86Config-4", os.R_OK):
                xcfg = xserver.start_existing_X ()
            else:
		xcfg = xf86config.XF86Config(videohw.primaryCard(),
                                         monitorhw, mousehw, kbd, runres)
                testxcfg = xserver.startX(runres, nofbmode, videohw, monitorhw,
					  mousehw, kbd)
        except RuntimeError:
            print " X startup failed, falling back to text mode"
            xcfg = xf86config.XF86Config(videohw.primaryCard(),
                                         monitorhw, mousehw, kbd, runres)
            display_mode = 't'
            time.sleep(2)            
    else:
        # XXX x_already_set is a hack, see above
        if x_already_set:
            card = videocard.VideoCard()
        else:
            card = videohw.primaryCard()
        xcfg = xf86config.XF86Config(card, monitorhw, mousehw, kbd, runres)
else:
    # text mode
    import xf86config

    # only probe X related stuff if we're doing an install
    if iutil.getArch() == "s390" or iutil.getArch() == "s390x":
        # XXX why doesn't videohw.primaryCard() dtrt on s390?
        card = videocard.VideoCard()
    else:
        card = videohw.primaryCard()
    xcfg = xf86config.XF86Config(card, monitorhw, mousehw, kbd, runres)



import configFileData
configFile = configFileData.configFileData()
configFileData = configFile.getConfigData()

#
# setup links required by graphical mode if installing and verify display mode
#
if (display_mode == 'g'):
    if not flags.test and flags.setupFilesystems:
        for i in ( "imrc", "im_palette.pal", "gtk-2.0", "services",
                   "protocol", "pango", "nsswitch.conf"):
            try:
                os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
            except:
                pass

    # display splash screen
    from splashscreen import splashScreenShow
    splashScreenShow(configFileData)

    if nofallback:
        from gui import InstallInterface
    else:
        try:
            from gui import InstallInterface
        except:
            # if we're not going to really go into GUI mode, we need to get
            # back to vc1 where the text install is going to pop up.
            if startXServer:
                isys.vtActivate (1)
            print "GUI installer startup failed, falling back to text mode."
            display_mode = 't'
            time.sleep(2)            
            from text import InstallInterface

if (display_mode == 't'):
    from text import InstallInterface
    from text import stepToClasses


# we like to have a way to shoot text mode back at a display
if xmode:
    os.environ["TERM"] = "xterm"
    import gtk
    from gnome import zvt

    def child_died (widget, *args):
        gtk.mainquit()

    win = gtk.Window ()
    zvt = zvt.Term (80, 24)
    zvt.connect ("child_died", child_died)
    zvt.set_del_key_swap(gtk.TRUE)
    win.add (zvt)
    win.show_all ()
    child = zvt.forkpty()
    if child != 0:
        gtk.mainloop()
        try:
            pid, status = os.waitpid(child, 0)
        except OSError:
            pass
        sys.exit (0)

if display_mode == "t":
    intf = InstallInterface ()
else:
    # determine the mode we actually ended up in
    intf = InstallInterface ()

# imports after setting up the path
if method:
    if method.startswith('cdrom://'):
        from image import CdromInstallMethod
        method = CdromInstallMethod(method[8:], intf.messageWindow,
				    intf.progressWindow)
    elif method.startswith('nfs:/'):
        from image import NfsInstallMethod
        method = NfsInstallMethod(method[5:])
    elif method.startswith('nfsiso:/'):
        from image import NfsIsoInstallMethod
        method = NfsIsoInstallMethod(method[8:], intf.messageWindow)
    elif method.startswith('ftp://') or method.startswith('http://'):
        from urlinstall import UrlInstallMethod
        method = UrlInstallMethod(method, rootPath)
    elif method.startswith('hd://'):
        method = method[5:]

        i = string.index(method, ":")
        drive = method[0:i]
        method = method[i+1:]
        
        i = string.index(method, "/")
        type = method[0:i]
        dir = method[i+1:]

        from harddrive import HardDriveInstallMethod
        method = HardDriveInstallMethod(drive, type, dir, intf.messageWindow)
    elif method.startswith('oldhd://'):
        method = method[8:]

        i = string.index(method, ":")
        drive = method[0:i]
        method = method[i+1:]
        
        i = string.index(method, "/")
        type = method[0:i]
        dir = method[i+1:]
        
        from harddrive import OldHardDriveInstallMethod
        method = OldHardDriveInstallMethod(drive, type, dir)
    else:
        print "unknown install method:", method
        sys.exit(1)

floppyDevice = floppy.probeFloppyDevice()

# create device nodes for detected devices if we're not running in test mode
if not flags.test and flags.setupFilesystems:
    iutil.makeDriveDeviceNodes()

id = instClass.installDataClass(extraModules, floppyDevice, configFileData)
#id = instClass.installDataClass(extraModules, floppyDevice)

id.x_already_set = x_already_set

if mousehw:
    id.setMouse(mousehw)

if videohw:
    id.setVideoCard(videohw)

if monitorhw:
    id.setMonitor(monitorhw)

if xcfg:
    id.setXconfig(xcfg)

if kbd:
    id.setKeyboard(kbd)
    
instClass.setInstallData(id)

dispatch = dispatch.Dispatcher(intf, id, method, rootPath)

if lang:
    dispatch.skipStep("language", permanent = 1)
    instClass.setLanguage(id, lang)
            
if keymap:
    dispatch.skipStep("keyboard", permanent = 1)
    instClass.setKeyboard(id, keymap)

instClass.setSteps(dispatch)

# We shouldn't need this again
# XXX
#del id

#
# XXX This is surely broken
#
#if iutil.getArch() == "sparc":
#    import kudzu
#    mice = kudzu.probe (kudzu.CLASS_MOUSE, kudzu.BUS_UNSPEC, kudzu.PROBE_ONE);
#    if mice:
#	(mouseDev, driver, descr) = mice[0]
#	if mouseDev == 'sunmouse':
#	    instClass.addToSkipList("mouse")
#	    instClass.setMouseType("Sun - Mouse", "sunmouse")

# comment out the next line to make exceptions non-fatal
sys.excepthook = lambda type, value, tb, dispatch=dispatch, intf=intf: handleException(dispatch, intf, (type, value, tb))

try:
    intf.run(id, dispatch, configFileData)
except SystemExit, code:
    intf.shutdown()
except:
    handleException(dispatch, intf, sys.exc_info())

del intf
