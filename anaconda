#!/usr/bin/python
#
# anaconda: The Red Hat Linux Installation program
#
# (in alphabetical order...)
#
# Brent Fox <bfox@redhat.com>
# Mike Fulbright <msf@redhat.com>
# Jakub Jelinek <jakub@redhat.com>
# Jeremy Katz <katzj@redhat.com>
# Erik Troan <ewt@redhat.com>
# Matt Wilson <msw@redhat.com>
#
# ... And a many others
#
# Copyright 2001 Red Hat, Inc.
#
# This software may be freely redistributed under the terms of the GNU
# library public license.
#
# You should have received a copy of the GNU Library Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

# This toplevel file is a little messy at the moment...

import sys, os

# For anaconda in test mode
if (os.path.exists('isys')):
    sys.path.append('edd')
    sys.path.append('libfdisk')
    sys.path.append('balkan')
    sys.path.append('gnome-map')
    sys.path.append('isys')
    sys.path.append('textw')
    sys.path.append('iw')
    sys.path.append('installclasses')
    sys.path.append('edd')
else:
    sys.path.append('/usr/lib/anaconda')
    sys.path.append('/usr/lib/anaconda/textw')
    sys.path.append('/usr/lib/anaconda/iw')
    sys.path.append('/usr/lib/anaconda/installclasses')

# do this early to keep our import footprint as small as possible
# Python passed my path as argv[0]!
# if sys.argv[0][-7:] == "syslogd":
if len(sys.argv) > 1:
    if sys.argv[1] == "--syslogd":
        from syslogd import Syslogd
        root = sys.argv[2]
        output = sys.argv[3]
        syslog = Syslogd (root, open (output, "a"))
	# this never returns

import signal, traceback, string, isys, iutil, time
from log import log
from translate import _
from exception import handleException
import dispatch
from flags import flags

# reset python's default SIGINT handler
signal.signal(signal.SIGINT, signal.SIG_DFL)

# Silly GNOME stuff
if os.environ.has_key('HOME'):
    os.environ['XAUTHORITY'] = os.environ['HOME'] + '/.Xauthority'
os.environ['HOME'] = '/tmp'
os.environ['LC_NUMERIC'] = 'C'

if os.environ.has_key ("ANACONDAARGS"):
    theargs = string.split (os.environ["ANACONDAARGS"])
else:
    theargs = sys.argv[1:]

try:
    (args, extra) = isys.getopt(theargs, 'GTRxtdr:fm:', 
          [ 'text', 'reconfig', 'xmode', 'test', 'debug', 'nofallback',
            'method=', 'rootpath=', 'pcic=', "overhead=",
	    'testpath=', 'mountfs', 'traceonly', 'kickstart=',
            'lang=', 'keymap=', 'module=', 'class=',
	    'expert', 'serial', 'lowres', 'nofb', 'rescue', 'nomount',
            'autostep'])
except TypeError, msg:
    sys.stderr.write("Error %s\n:" % msg)
    sys.exit(-1)

if extra:
    sys.stderr.write("Unexpected arguments: %s\n" % extra)
    sys.exit(-1)

# Save the arguments in case we need to reexec anaconda for kon
os.environ["ANACONDAARGS"] = string.join(sys.argv[1:])

# remove the arguments - gnome_init doesn't understand them
savedargs = sys.argv[1:]
sys.argv = sys.argv[:1]
sys.argc = 1

# Parameters for the main anaconda routine
#
rootPath = '/mnt/sysimage'	# where to instal packages
extraModules = []		# kernel modules to use
display_mode = 'g'		# try GUI by default
xmode = 0			# bring up text mode in a remote xterm?
debug = 0			# start up pdb immediately
traceOnly = 0			# don't run, just list modules we use
nofallback = 0			# if GUI mode fails, exit
rescue = 0			# run in rescue mode
rescue_nomount = 0		# don't automatically mount device in rescue
overhead = 0			# kilobytes of memory used already
runres = '800x600'		# resolution to run the GUI install in
nofbmode = 0			# don't use framebuffer X, no matter what
instClass = None		# the install class to use
progmode = 'install' 		# 'reconfig', 'rescue', or 'install'
method = None			# URL representation of install method
logFile = None			# may be a file object or a file name

#
# xcfg       - xserver info (?)
# mousehw    - mouseinfo info
# videohw    - videocard info
# monitorhw  - monitor info
# lang       - language to use for install/machine default
# keymap     - kbd map
#
xcfg = None
monitorhw = None
videohw = None
mousehw = None
lang = None
method = None
keymap = None
kbdtpye = None
progmode = None
customClass = None

#
# parse off command line arguments
#
for n in args:
    (str, arg) = n

    if (str == '--class'):
        customClass = arg
    elif (str == '-d' or str == '--debug'):
	debug = 1
    elif (str == '--expert'):
	flags.expert = 1 
    elif (str == '--keymap'):
        keymap = arg
    elif (str == '--kickstart'):
	from kickstart import Kickstart
        instClass = Kickstart(arg, flags.serial)
    elif (str == '--lang'):
        lang = arg
    elif (str == '--lowres'):
        runres = '640x480'
    elif (str == '-m' or str == '--method'):
	method = arg
	if method[0] == '@':
	    # ftp installs pass the password via a file in /tmp so
	    # ps doesn't show it
	    filename = method[1:]
	    method = open(filename, "r").readline()
	    method = method[:len(method) - 1]
	    os.unlink(filename)
    elif (str == '--module'):
	(path, subdir, name) = string.split(arg, ":")
	extraModules.append((path, subdir, name))
    elif (str == '--nofallback'):
	nofallback = 1
    elif (str == '--nofb'):
        nofbmode = 1
    elif (str == "--nomount"):
        rescue_nomount = 1
    elif (str == '--overhead'):
	overhead = int(arg)
    elif (str == '-R' or str == '--reconfig'):
        progmode = 'reconfig'
	rootPath = '/'
	logFile = "/var/log/reconfig.log"
	flags.setupFilesystems = 0
        flags.reconfig = 1
	customClass = 'reconfig'
    elif (str == '--rescue'):
        progmode = 'rescue'
    elif (str == "--autostep"):
	flags.autostep = 1
    elif (str == '-r' or str == '--rootpath'):
	rootPath = arg
	flags.setupFilesystems = 0
	logFile = sys.stderr
    elif (str == '--traceonly'):
	traceOnly = 1
    elif (str == '--serial'):
	logFile = "/tmp/install.log"
	flags.serial = 1
    elif (str == '-t' or str == '--test'):
	flags.test = 1
	flags.setupFilesystems = 0
	logFile = "/tmp/anaconda-debug.log"
    elif (str == '-T' or str == '--text'):
	display_mode = 't'
    elif (str == '-x' or str == '--xmode'):
	xmode = 1

#
# must specify install, rescue or reconfig mode
#

if (progmode == 'rescue'):
    if (not method):
	sys.stderr.write('--method required for rescue mode\n')
	sys.exit(1)

    import rescue, instdata, configFileData
    
    log.open (logFile)
    configFile = configFileData.configFileData()
    configFileData = configFile.getConfigData()
    
    id = instdata.InstallData([], "fd0", configFileData)
    rescue.runRescue("/mnt/sysimage", not rescue_nomount, id)

    # shouldn't get back here
    sys.exit(1)
elif (progmode == 'reconfig'):
    pass
else:
    if (not method):
	sys.stderr.write('no install method specified\n')
	sys.exit(1)

log.open (logFile)

if (debug):
    import pdb
    pdb.set_trace()

# don't let folks do anything stupid
if (not flags.test and os.getpid() > 90 and flags.setupFilesystems):
    sys.stderr.write(
	"You're running me on a live system! that's incredibly stupid.\n")
    sys.exit(1)

import isys
import instdata
import videocard
import monitor
import mouse
import floppy

# handle traceonly and exit
if traceOnly:

    if display_mode == 'g':
        sys.stderr.write("traceonly is only supported for text mode\n")
        sys.exit(0)
    
    # prints a list of all the modules imported
    from text import InstallInterface
    from text import stepToClasses
    import pdb
    import image
    import harddrive
    import urlinstall
    import mimetools
    import mimetypes
    import syslogd
    import installclass
    import re
    import rescue
    import xserver
    import configFileData
    import kickstart

    installclass.availableClasses()

    if iutil.getArch() == "i386":
	import edd

    if display_mode == 't':
        for step in stepToClasses.keys():
            if stepToClasses[step]:
                (mod, klass) = stepToClasses[step]
                exec "import %s" % mod
        
    for module in sys.__dict__['modules'].keys ():
        if module not in [ "__builtin__", "__main__" ]:
            foo = repr (sys.__dict__['modules'][module])
            bar = string.split (foo, "'")
            if len (bar) > 3:
                print bar[3]
        
    sys.exit(0)

iutil.setMemoryOverhead(overhead)

#
# override display mode if machine cannot nicely run X
#
if (not flags.test):
    if (iutil.memInstalled() < isys.MIN_GUI_RAM):
        print _("You do not have enough RAM to use the graphical installer.  "
                "Starting text mode.")
	display_mode = 't'
        time.sleep(2)

# Force text mode on IBM s390/s390x
#if iutil.getArch() == "s390" or iutil.getArch() == "s390x":
#	display_mode = 't'
        

if iutil.memInstalled() < isys.MIN_RAM:
    from snack import *

    screen = SnackScreen()
    ButtonChoiceWindow(screen, _('Fatal Error'),
			_('You do not have enough RAM to install Red Hat '
			  'Linux on this machine.\n'
			  '\n'
			  'Press <return> to reboot your system.\n'), 
			  buttons = (_("OK"),))
    screen.finish()
    sys.exit(0)

#
# handle class passed from loader
#
if customClass:
    import installclass

    classes = installclass.availableClasses(showHidden=1)
    for (className, objectClass, logo) in classes:
	if className == customClass:
		instClass = objectClass(flags.expert)

    if not instClass:
	sys.stderr.write("installation class %s not available\n" % customClass)
	sys.stderr.write("\navailable classes:\n")
	for (className, objectClass, logo) in classes:
	    sys.stderr.write("\t%s\n" % className)
	sys.exit(1)

#
# if no instClass declared by user figure it out based on other cmdline args
#
if not instClass:
    from installclass import DefaultInstall
    instClass = DefaultInstall(flags.expert)

# this lets install classes force text mode instlls
if instClass.forceTextMode:
    display_mode = 't'

#
# find out what video hardware is available to run installer 
#
if os.environ.has_key('DISPLAY') and display_mode == 'g':
    x_already_set = 1
else: x_already_set = 0

    
mousehw    = mouse.Mouse(skipProbe = 1)
#if display_mode == 'g':

# lets try always probing this stuff, probably ought to provide way to
# skip probing if we have really sensitive hw that HAS to use text mode
if 1:
    sys.stdout.write(    _("Probing for video card:   "))
    fbdev = None
    videohw    = videocard.VideoCardInfo()

    if videohw and videohw.primaryCard():
        sys.stdout.write(videohw.primaryCard().shortDescription()+'\n')
        fbdev = videohw.primaryCard().getDevice()
    else:
        sys.stdout.write(_("Unable to probe\n"))

    sys.stdout.write(    _("Probing for monitor type: "))
    monitorhw  = monitor.MonitorInfo(fbDevice=fbdev)
    sys.stdout.write(monitorhw.shortDescription()+'\n')

    # only probe if we're installing a real box or
    # we're running in a virtual console and need to startup X server
    if not os.environ.has_key('DISPLAY') or flags.setupFilesystems:
	sys.stdout.write(_("Probing for mouse type:   "))
	mousehw.probe (frob = 1)
        sys.stdout.write(mousehw.shortDescription()+'\n')
    else:
	sys.stdout.write(_("Skipping mouse probe.\n"))

# determine which mode reconfig should use
if (progmode == 'reconfig'):
    if (iutil.getDefaultRunlevel() == '5' and
        os.access("/etc/X11/XF86Config", os.R_OK)):
        display_mode = 'g'
    else:
        display_mode = 't'

if (display_mode != 't' and method and
    ((len (method) >= 6 and method[:6] == "ftp://")
    or (len (method) >= 7 and method[:7] == "http://")
    or (len (method) >= 5 and method[:5] == "hd://"))):
    print _("Graphical installation not available for %s installs.  "
            "Starting text mode.") % (string.split(method, ':')[0],)
    display_mode = 't'
    time.sleep(2)

# if no mouse we force text mode
mousedev = mousehw.get()
if display_mode != 't' and mousedev[0] == "None - None":
    print _("No mouse was detected.  A mouse is required for graphical "
            "installation.  Starting text mode.")
    display_mode = 't'
    time.sleep(2)

#
# startup X server is we're not already running under an X session
#
startXServer = 0
if display_mode == 'g':
    import xf86config
    
    if not os.environ.has_key('DISPLAY'):
        startXServer = 1
        import xserver
        try:
            if os.access("/etc/X11/XF86Config", os.R_OK) or os.access("/etc/X11/XF86Config-4", os.R_OK):
                xcfg = xserver.start_existing_X ()
            else:
                xcfg = xserver.startX (runres, nofbmode, videohw, monitorhw,
                                       mousehw)
        except RuntimeError:
            print " X startup failed, falling back to text mode"
            xcfg = xf86config.XF86Config(videohw.primaryCard(),
                                         monitorhw, mousehw, runres)
            display_mode = 't'
            time.sleep(2)            
    else:
        if x_already_set: card = videocard.VideoCard()
        else: card = videohw.primaryCard()
        xcfg = xf86config.XF86Config(card, monitorhw, mousehw, runres)

elif progmode != 'reconfig':
    import xf86config

    # only probe X related stuff if we're doing an install
    if iutil.getArch() == "s390" or iutil.getArch() == "s390x":
        card = videocard.VideoCard()
        else: card = videohw.primaryCard()
        xcfg = xf86config.XF86Config(card, monitorhw, mousehw, runres)

import configFileData
configFile = configFileData.configFileData()
configFileData = configFile.getConfigData()

#
# setup links required by graphical mode if installing and verify display mode
#
if (display_mode == 'g'):
    if not flags.test and flags.setupFilesystems:
        for i in ( "imrc", "im_palette.pal", "gtk", "services",
                   "protocol"):
            try:
                os.symlink ("../mnt/runtime/etc/" + i, "/etc/" + i)
            except:
                pass

    # display splash screen
    from splashscreen import splashScreenShow
    splashScreenShow(configFileData)

    if nofallback:
        from gui import InstallInterface
    else:
        try:
            from gui import InstallInterface
        except:
            # if we're not going to really go into GUI mode, we need to get
            # back to vc1 where the text install is going to pop up.
            if startXServer:
                isys.vtActivate (1)
            print "GUI installer startup failed, falling back to text mode."
            display_mode = 't'
            time.sleep(2)            
            from text import InstallInterface

if (display_mode == 't'):
    from text import InstallInterface
    from text import stepToClasses


# we like to have a way to shoot text mode back at a display
if xmode:
    os.environ["TERM"] = "xterm"
    from gtk import *
    from gnome.zvt import *

    def child_died (widget, *args):
        mainquit()

    win = GtkWindow ()
    zvt = ZvtTerm (80, 24)
    zvt.connect ("child_died", child_died)
    zvt.set_del_key_swap(TRUE)
    win.add (zvt)
    win.show_all ()
    child = zvt.forkpty()
    if child != 0:
        mainloop()
        try:
            pid, status = os.waitpid(child, 0)
        except OSError:
            pass
        sys.exit (0)

if display_mode == "t":
    intf = InstallInterface ()
else:
    # determine the mode we actually ended up in
    intf = InstallInterface ()

# imports after setting up the path
if method:
    if (method[0:8] == "cdrom://"):
        from image import CdromInstallMethod
        method = CdromInstallMethod(method[8:], intf.messageWindow,
				    intf.progressWindow)
    elif (method[0:5] == "nfs:/"):
        from image import NfsInstallMethod
        method = NfsInstallMethod(method[5:])
    elif (method[0:6] == "ftp://" or method[0:7] == "http://"):
        from urlinstall import UrlInstallMethod
        method = UrlInstallMethod(method)
    elif (method[0:5] == "hd://"):
        method = method[5:]

        i = string.index(method, ":")
        drive = method[0:i]
        method = method[i+1:]
        
        i = string.index(method, "/")
        type = method[0:i]
        dir = method[i+1:]

        from harddrive import HardDriveInstallMethod
        method = HardDriveInstallMethod(drive, type, dir, intf.messageWindow)
    elif (method[0:8] == "oldhd://"):
        method = method[8:]

        i = string.index(method, ":")
        drive = method[0:i]
        method = method[i+1:]
        
        i = string.index(method, "/")
        type = method[0:i]
        dir = method[i+1:]
        
        from harddrive import OldHardDriveInstallMethod
        method = OldHardDriveInstallMethod(drive, type, dir)
    else:
        print "unknown install method:", method
        sys.exit(1)

floppyDevice = floppy.probeFloppyDevice()

id = instClass.installDataClass(extraModules, floppyDevice, configFileData)
#id = instClass.installDataClass(extraModules, floppyDevice)

id.x_already_set = x_already_set

if mousehw:
    id.setMouse(mousehw)

if videohw:
    id.setVideoCard(videohw)

if monitorhw:
    id.setMonitor(monitorhw)

if xcfg:
    id.setXconfig(xcfg)
    
instClass.setInstallData(id)

dispatch = dispatch.Dispatcher(intf, id, method, rootPath)

if lang:
    dispatch.skipStep("language", permanent = 1)
    instClass.setLanguage(id, lang)
            
if keymap:
    dispatch.skipStep("keyboard", permanent = 1)
    instClass.setKeyboard(id, keymap)

instClass.setSteps(dispatch)

# We shouldn't need this again
# XXX
#del id

#
# XXX This is surely broken
#
#if iutil.getArch() == "sparc":
#    import kudzu
#    mice = kudzu.probe (kudzu.CLASS_MOUSE, kudzu.BUS_UNSPEC, kudzu.PROBE_ONE);
#    if mice:
#	(mouseDev, driver, descr) = mice[0]
#	if mouseDev == 'sunmouse':
#	    instClass.addToSkipList("mouse")
#	    instClass.setMouseType("Sun - Mouse", "sunmouse")

try:
    intf.run(id, dispatch, configFileData)
except SystemExit, code:
    intf.shutdown()
except:
    handleException(id, intf, sys.exc_info())

del intf
